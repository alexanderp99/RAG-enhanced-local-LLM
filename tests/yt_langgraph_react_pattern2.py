# -*- coding: utf-8 -*-
"""YT LangGraph ReAct Pattern.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14ncV0nviLcP9IDzmFSRGSXb7Bgpz212v
"""

from langchain_ollama import ChatOllama
from langgraph.prebuilt import ToolNode
from pydantic import BaseModel

from modelTypes import Modeltype

llm = ChatOllama(model=Modeltype.LLAMA3_1_8B.value, temperature=0)

"""### Tools"""


def multiply(a: int, b: int) -> int:
    """Multiply a and b.

    Args:
        a: first int
        b: second int
    """
    return a * b


# This will be a tool
def add(a: int, b: int) -> int:
    """Adds a and b.

    Args:
        a: first int
        b: second int
    """
    return a + b


def divide(a: int, b: int) -> float:
    """Divide a and b.

    Args:
        a: first int
        b: second int
    """
    return a / b


import yfinance as yf


def get_stock_price(ticker: str) -> float:
    """Gets a stock price from Yahoo Finance.

    Args:
        ticker: ticker str
    """
    # """This is a tool for getting the price of a stock when passed a ticker symbol"""
    stock = yf.Ticker(ticker)
    return stock.info['previousClose']


from langchain_community.tools import DuckDuckGoSearchRun

search = DuckDuckGoSearchRun()

tools = [add, multiply, divide, get_stock_price, search]
llm_with_tools = llm.bind_tools(tools)


# Node
def reasoner(state):
    query = state["query"]
    messages = state["messages"]
    # System message
    sys_msg = SystemMessage(
        content="You are a helpful assistant tasked with using search, the yahoo finance tool and performing arithmetic on a set of inputs.")
    message = HumanMessage(content=query)
    messages.append(message)
    result = [llm_with_tools.invoke([sys_msg] + messages)]
    return {"messages": result}


from typing import Annotated, TypedDict, Literal, Union, Any
import operator
from langchain_core.messages import AnyMessage, HumanMessage, SystemMessage


class GraphState(TypedDict):
    """State of the graph."""
    query: str
    finance: str
    final_answer: str
    # intermediate_steps: Annotated[list[tuple[AgentAction, str]], operator.add]
    messages: Annotated[list[AnyMessage], operator.add]


from langgraph.graph import START, StateGraph

# Graph
workflow = StateGraph(GraphState)

# Add Nodes
workflow.add_node("reasoner", reasoner)
workflow.add_node("tools", ToolNode(tools))  # for the tools

# Add Edges
workflow.add_edge(START, "reasoner")


def tools_condition(
        state: Union[list[AnyMessage], dict[str, Any], BaseModel],
        messages_key: str = "messages",
) -> Literal["tools", "__end__"]:
    """Use in the conditional_edge to route to the ToolNode if the last message"""
    if isinstance(state, list):
        ai_message = state[-1]
    elif isinstance(state, dict) and (messages := state.get(messages_key, [])):
        ai_message = messages[-1]
    elif messages := getattr(state, messages_key, []):
        ai_message = messages[-1]
    else:
        raise ValueError(f"No messages found in input state to tool_edge: {state}")
    if hasattr(ai_message, "tool_calls") and len(ai_message.tool_calls) > 0:
        return "tools"
    return "__end__"


workflow.add_conditional_edges(
    "reasoner",
    # If the latest message (result) from node reasoner is a tool call -> tools_condition routes to tools
    # If the latest message (result) from node reasoner is a not a tool call -> tools_condition routes to END
    tools_condition,
)
workflow.add_edge("tools", "reasoner")
react_graph = workflow.compile()

"""


response = react_graph.invoke({"query": "What is 2 times Brad Pitt's age (43)?", "messages": []})

response['messages'][-1].pretty_print()

"""

response = react_graph.invoke({"query": "What is the stock price of Apple divided by two??", "messages": []})

for m in response['messages']:
    m.pretty_print()

response = react_graph.invoke({"query": "What is the color of the sky?", "messages": []})
response['messages'][-1].pretty_print()
